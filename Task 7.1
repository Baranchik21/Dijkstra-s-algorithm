graph = {}              #Реализуем графы с помощью хещ-таблиц
graph["start"] = {}
graph["start"]["a"] = 5 #Вес ребра из начала до точки а
graph["start"]["b"] = 2

graph["a"] = {}
graph["a"]["c"] = 4
graph["a"]["d"] = 2

graph["b"] = {}
graph["b"]["a"] = 8
graph["b"]["d"] = 7

graph["c"] = {}
graph["c"]["d"] = 6
graph["c"]["fin"] = 3

graph["d"] = {}
graph["d"]["fin"] = 1
 
graph["fin"] = {}        #Конечный узел не имеет соседей

infinity = float("inf")
costs = {}
costs["a"] = 5
costs["b"] = 2
costs["c"] = infinity #Бесконечность , так как мы ещё не знаем сколько времени потребуется для достижения этого узла
costs["d"] = infinity
costs["fin"] = infinity

parents = {}
parents["a"] = "start"
parents["b"] = "start"
parents["fin"] = None 

#-------------------------------------------------
# Функция для нахождения минимальной стоимости узла
#-------------------------------------------------

def find_lowest_cost_node(costs):
    lowest_cost = float("inf") #Бесконечность 
    lowest_cost_node = None #Вернет None если ничего не передать
    for node in costs: #Перебираем все узлы
        cost = costs[node]  #Получаем стоимость соседей от узла которого нашли ранее 
        if cost < lowest_cost and node not in processed: #Если стоимость полученного узла меньше стоимости уже найденного узла и узел с новой стоимостью еще не проверялся 
            lowest_cost = cost #Изменяется стоимость узла на новую
            lowest_cost_node = node #Изменяется узел на новый
    return lowest_cost_node #Возращаем узел с наименьшей стоимостью

processed = [] #Массив для обработанных данных 
node = find_lowest_cost_node(costs) #Нахождение узла с наименьшей стоимостью среди необработанных
while node is not None: #Если обработанны все узлы - цикл завершен
    cost = costs[node] #Получаем стоимость соседей от узла которого нашли ранее (узел с наименьшей стоимостью)
    neighbors = graph[node] #Получаем соседей от узла которого нашли ранее (узел с наименьшей стоимостью)
    for n in neighbors.keys(): #Перебираем всех соседей текущего узла
        new_cost = cost + neighbors[n] #Вычисляем сколько времени потребуется для достижения данного узла через самый дешевый путь
        if costs[n] > new_cost: #Сравниваем стоимость дохождения до данного узла 
            costs[n] = new_cost #Если новый путь дешевле мы обновляем стоитьсть дохождения до данного узла
            parents[n] = node #Так как мы нашли новый путь, соответственно у найденного нами  узла мы обновим родителя
    processed.append(node) #Узел отмечается как отработанный и помещается в отдельный массив 
    node = find_lowest_cost_node(costs) #Ищем следующий узел для обработки

print(costs)
